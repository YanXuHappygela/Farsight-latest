/*=========================================================================
Copyright 2009 Rensselaer Polytechnic Institute
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
=========================================================================*/

/***
/brief Code to convert superellise xml file to SWC file.
/author  Amit Mukherjee
/date May 09, 2009
*/


#include "tinyxml.h"
#include "TraceNode.h"
#include <string>
#include <fstream>
#include <map>
#include <vector>

void WriteSWCFile(const std::string& , const std::vector<TraceNode*>& );
bool ReadNodeXMLFile(const char* , std::vector<TraceNode*>& );

struct TreeNode {
	TraceNode* tnode;
	long PID;
	TreeNode(TraceNode* t, long pid) {
		tnode = t;
		PID = pid;
	}
};

int main (int argc, char *argv[])	{

	if (argc != 3)	{
		std::cout << "Usage: "<<argv[0] << " [SuperellipseXMLFilename] [SWCFilename]" <<std::endl;
		return EXIT_FAILURE;
	}
	std::string XMLFilename(argv[1]);
	std::string SWCFilename(argv[2]);
	std::vector<TraceNode*> NodeContainer ;
	std::cout << "Reading file " << argv[1] << std::endl;
	if (ReadNodeXMLFile(XMLFilename.c_str(), NodeContainer ) )	{
		std::cout << "Reading success. " << NodeContainer.size() << " superellise found" << std::endl << "Constructing SWC tree" << std::endl;
		WriteSWCFile(SWCFilename, NodeContainer);
	}
}

void WriteSWCFile(const std::string& SWCFilename, const std::vector<TraceNode*>& NodeContainer)	{

	std::ofstream swc;
	swc.open(SWCFilename.c_str(), std::ios::out);
	// you can use this as a parameter to set the minimum length of small trees
	int  LENGTH = 5;

	const unsigned int numNodes = NodeContainer.size();
	std::map<long, int> reg;

	swc << "# File generated by Superellipsoid to SWC converter" << std::endl;

	// scan the graph
	unsigned int numDone = 1, numTrees = 1;;
	std::vector<TreeNode> Tree;
	Tree.reserve(1000);
	Tree.clear();

	//initialize the first element as grandparent
	//if you know the SOMA, then this should be the SOMA and initilise likewise, here I have choosen arbit.
	TraceNode* node = NodeContainer[0];
	unsigned int ID = 1;
	reg[node->ID] = ID;

	//swc << ID << " 10 " << node->loc[0] << " " << node->loc[1] << " " << node->loc[2] << " " << node->radius << "  -1" << std::endl;
	Tree.push_back(TreeNode(node, -1));
	long watchdog = 1;

	while (numDone < numNodes)	{
		watchdog++;
		if (watchdog > 500000) {
			break;
		}
		unsigned char IsChanged = 0;
		std::vector<TraceNode*>::const_iterator fit = NodeContainer.begin();
		for(fit = NodeContainer.begin(); fit < NodeContainer.end(); fit++)	{
			if (reg[(*fit)->ID] == 0)	{
				for (unsigned int i = 0; i < (*fit)->nbrID.size(); i++)	{
					if (reg[(*fit)->nbrID[i]] != 0)	{
						ID++;
						Tree.push_back(TreeNode((*fit), reg[(*fit)->nbrID[i]]));
						/*swc << ID << " 10 " << (*fit)->loc[0] << " " << (*fit)->loc[1] << " " <<
							(*fit)->loc[2] << " " << (*fit)->radius << "  " << reg[(*fit)->nbrID[i]] << std::endl;
						*/
						std::cout <<"\r" << (numDone*100/numNodes) << " % complete          ";
						reg[(*fit)->ID] = ID;
						IsChanged = 1;
						numDone++;
						break;
					}
				}
			}
			else	{
				if(IsChanged == 1)
					break;
			}
		}

		std::vector<TraceNode*>::const_reverse_iterator rit;
		for(rit = NodeContainer.rbegin(); rit < NodeContainer.rend(); rit++)	{
			if (reg[(*rit)->ID] == 0)	{
				for (unsigned int i = 0; i < (*rit)->nbrID.size(); i++)	{
					if (reg[(*rit)->nbrID[i]] != 0)	{
						ID++;
						Tree.push_back(TreeNode((*rit), reg[(*rit)->nbrID[i]]));
						/*swc << ID << " 10 " << (*rit)->loc[0] << " " << (*rit)->loc[1] << " " <<
							(*rit)->loc[2] << " " << (*rit)->radius << "  " << reg[(*rit)->nbrID[i]] << std::endl;
						*/
						std::cout <<"\r" << (numDone*100/numNodes) << " % complete          ";
						reg[(*rit)->ID] = ID;
						IsChanged = 2;
						numDone++;
						break;
					}
				}
			}
			else	{
				if(IsChanged == 2)
					break;
			}
		}

		if ((IsChanged == 0) && (numDone < numNodes))	{
			//entire tree is scanned, write Tree is Treelength exceeds threshold
			if (Tree.size() >  LENGTH) {
				for (std::vector<TreeNode>::iterator it = Tree.begin(); it != Tree.end(); ++it) {
					TraceNode* tn = (*it).tnode;
					swc << tn->ID << " 0 " << tn->loc[0] << " " << tn->loc[1] << " " << tn->loc[2] << " " << tn->radius << " " << (*it).PID << std::endl;
				}
			}
			else {
				for (std::vector<TreeNode>::iterator it = Tree.begin(); it != Tree.end(); ++it) {
					TraceNode* tn = (*it).tnode;
					swc << tn->ID << " 1 " << tn->loc[0] << " " << tn->loc[1] << " " << tn->loc[2] << " " << tn->radius << " " << (*it).PID << std::endl;
			}

			}  

			//begin a new tree
			Tree.clear();
			std::vector<TraceNode*>::const_iterator fit;
			for(fit = NodeContainer.begin(); fit < NodeContainer.end(); fit++)	{
				if (reg[(*fit)->ID] == 0)	{
					ID++;
					//swc << ID << " 10 " << (*fit)->loc[0] << " " << (*fit)->loc[1] << " " << (*fit)->loc[2] << " " << (*fit)->radius << "  -1" << std::endl;
					Tree.push_back(TreeNode((*fit), -1));
					std::cout <<"\r" << (numDone*100/numNodes) << " % complete          ";
					reg[(*fit)->ID] = ID;
					numDone++;
					numTrees++;
					break;
				}
			}
		}
	}
	std::cout << std::endl << "Done ... Saving in file " << SWCFilename <<std::endl;
	swc.close();
}



bool ReadNodeXMLFile(const char* xmlfname, std::vector<TraceNode*>& NodeContainer) {
	NodeContainer.reserve(10000);
	TiXmlDocument doc(xmlfname);
	if (!doc.LoadFile()) {
		return false;
	}

	//scan each Superellipse
	TiXmlNode* xmlnode;

	for ( xmlnode = doc.FirstChild(); xmlnode != 0; xmlnode = xmlnode->NextSibling()) 	{

		//verify if the xmlnode is a type element
		if (xmlnode->Type()!=TiXmlNode::ELEMENT)	{
			continue;
		}

		//verify if the xmlnode is a superellipse, if not
		if (strcmp(xmlnode->Value(),"Superellipse"))	{
			continue;
		}

		TraceNode *n = new TraceNode();
		TiXmlAttribute* pAttrib = xmlnode->ToElement()->FirstAttribute();
		while (pAttrib)	{
			if (!strcmp(pAttrib->Name(),"ID"))	{
				int temp = -1;
				if (pAttrib->QueryIntValue(&temp)==TIXML_SUCCESS)	{
					n->ID = temp;
				}
			}
			else if (!strcmp(pAttrib->Name(),"TraceID"))	{
				int temp = -1;
				if (pAttrib->QueryIntValue(&temp)==TIXML_SUCCESS)	{
					n->TraceID = temp;
				}
			}

			else if (!strcmp(pAttrib->Name(),"x"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					n->loc[0] = temp;
				}
			}

			else if (!strcmp(pAttrib->Name(),"y"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					n->loc[1] = temp;
				}
			}

			else if (!strcmp(pAttrib->Name(),"z"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					n->loc[2] = temp;
				}
			}

			else if (!strcmp(pAttrib->Name(),"a1"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					if (n->radius > 0.0)	{
						n->radius = 0.5*(n->radius + temp);
					}
					else {
						n->radius = temp;
					}
				}
			}

			else if (!strcmp(pAttrib->Name(),"a2"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					if (n->radius > 0.0)	{
						n->radius = 0.5*(n->radius + temp);
					}
					else {
						n->radius = temp;
					}
				}
			}

			pAttrib=pAttrib->Next();
		}

		TiXmlNode* nbr;
		for ( nbr = xmlnode->FirstChild(); nbr != 0; nbr = nbr->NextSibling())		{
			TiXmlAttribute* nAttr = nbr->ToElement()->FirstAttribute();
			if (!strcmp(nAttr->Name(),"ID"))	{
				int temp = -1;
				if (nAttr->QueryIntValue(&temp)==TIXML_SUCCESS)
					n->nbrID.push_back(temp);
			}
		}

		//store in container
		NodeContainer.push_back(n);
	}
	return true;

}
